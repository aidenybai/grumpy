// Copyright 2018 Aiden Bai, All Rights Reserved
class Grumpy extends Map{constructor(r){super(r),Object.defineProperty(this,'_array',{value:null,writable:!0,configurable:!0}),Object.defineProperty(
this,'_keyArray',{value:null,writable:!0,configurable:!0})}set(r,e){if(this._array=null,this._keyArray=null,void 0===r)throw new Error('Parameter key
 not provided.');if(void 0===e)throw new Error('Parameter value not provided.');return super.set(r,e)}delete(r){if(this._array=null,this._keyArray=nu
ll,void 0===r)throw new Error('Parameter key not provided.');return super.delete(r)}array(){return this._array&&this._array.length===this.size||(this
._array=[...this.values()]),this._array}keyArray(){return this._keyArray&&this._keyArray.length===this.size||(this._keyArray=[...this.keys()]),this._
keyArray}first(r){if(void 0===r)return this.values().next().value;if(isNaN(r))throw new TypeError('The count must be a number.');if(!Number.isInteger
(r)||r<1)throw new RangeError('The count must be an integer greater than 0.');r=Math.min(this.size,r);const e=new Array(r),t=this.values();for(let n=
0;n<r;n++)e[n]=t.next().value;return e}firstKey(r){if(void 0===r)return this.keys().next().value;if(isNaN(r))throw new TypeError('The count must be a
 number.');if(!Number.isInteger(r)||r<1)throw new RangeError('The count must be an integer greater than 0.');r=Math.min(this.size,r);const e=new Arra
y(r),t=this.keys();for(let n=0;n<r;n++)e[n]=t.next().value;return e}last(r){const e=this.array();if(void 0===r)return e[e.length-1];if(isNaN(r))throw
 new TypeError('The count must be a number.');if(!Number.isInteger(r)||r<1)throw new RangeError('The count must be an integer greater than 0.');retur
n e.slice(-r)}lastKey(r){const e=this.keyArray();if(void 0===r)return e[e.length-1];if(isNaN(r))throw new TypeError('The count must be a number.');if
(!Number.isInteger(r)||r<1)throw new RangeError('The count must be an integer greater than 0.');return e.slice(-r)}random(r){let e=this.array();if(vo
id 0===r)return e[Math.floor(Math.random()*e.length)];if(isNaN(r))throw new TypeError('The count must be a number.');if(!Number.isInteger(r)||r<1)thr
ow new RangeError('The count must be an integer greater than 0.');if(0===e.length)return[];const t=new Array(r);e=e.slice();for(let n=0;n<r;n++)t[n]=
e.splice(Math.floor(Math.random()*e.length),1)[0];return t}randomKey(r){let e=this.keyArray();if(void 0===r)return e[Math.floor(Math.random()*e.lengt
h)];if(isNaN(r))throw new TypeError('The count must be a number.');if(!Number.isInteger(r)||r<1)throw new RangeError('The count must be an integer gr
eater than 0.');if(0===e.length)return[];const t=new Array(r);e=e.slice();for(let n=0;n<r;n++)t[n]=e.splice(Math.floor(Math.random()*e.length),1)[0];
return t}sift(r,e){e&&(r=r.bind(e));const t=this.size;for(const[e,t]of this)r(t,e,this)&&this.delete(e);return t-this.size}filter(r,e){e&&(r=r.bind(e
));const t=new Grumpy;for(const[e,n]of this)r(n,e,this)&&t.set(e,n);return t}map(r,e){e&&(r=r.bind(e));const t=new Array(this.size);let n=0;for(const
[e,s]of this)t[n++]=r(s,e,this);return t}some(r,e){e&&(r=r.bind(e));for(const[e,t]of this)if(r(t,e,this))return!0;return!1}every(r,e){e&&(r=r.bind(e)
);for(const[e,t]of this)if(!r(t,e,this))return!1;return!0}reduce(r,e){let t;if(void 0!==e){t=e;for(const[e,n]of this)t=r(t,n,e,this)}else{let e=!0;fo
r(const[n,s]of this)e?(t=s,e=!1):t=r(t,s,n,this)}return t}each(r,e){return this.forEach(r,e),this}clone(){return new this.constructor(this)}concat(..
.r){const e=this.clone();for(const t of r)for(const[r,n]of t)e.set(r,n);return e}cut(r,e){void 0!==e&&(r=r.bind(e));const t=[new Grumpy,new Grumpy];f
or(const[e,n]of this)r(n,e,this)?t[0].set(e,n):t[1].set(e,n);return t}equals(r){return!!r&&(this===r||(this.size,r.size,!1))}deleteAll(){const r=[];f
or(const e of this.values())e.delete&&r.push(e.delete());return r}sort(r=((r,e)=>+(r>e)||+(r===e)-1)){return new Grumpy([...this.entries()].sort((e,t
)=>r(e[1],t[1],e[0],t[0])))}}module.exports=Grumpy;
