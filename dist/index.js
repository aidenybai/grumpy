"use strict";class Grumpy extends Map{constructor(r){if(super(),this._array=null,this._keyArray=null,void 0!==r)for(const[t,e]of r)this.set(t,e)}array(){return this._array&&this._array.length===this.size||(this._array=[...this.values()]),this._array}clone(){return new Grumpy([...this.entries()])}concat(...r){if(void 0===r)throw new Error("Groups is a required argument");const t=this.clone();for(const e of r)for(const[r,i]of e)t.set(r,i);return t}cut(r,t){if(void 0===r)throw new Error("Function is a required argument");void 0!==t&&(r=r.bind(t));let e=[new Grumpy,new Grumpy];for(const[t,i]of this)r(i,t,this)?e[0].set(t,i):e[1].set(t,i);return e}delete(r,t){if(this._array=null,this._keyArray=null,void 0===r)throw new Error("Key is a required argument");t?setTimeout(()=>{this.delete(r)},t):super.delete(r)}each(r,t){if(void 0===r)throw new Error("Function is a required argument");return this.forEach(r,t),this}equals(r){if(!r)return!1;if(this===r)return!0;if(this.size!==r.size)return!1;for(const[t,e]of this)if(!r.has(t)||e!==r.get(t))return!1;return!0}every(r,t){if(void 0===r)throw new Error("Function is a required argument");t&&(r=r.bind(t));for(const[t,e]of this)if(!r(e,t,this))return!1;return!0}filter(r,t){if(void 0===r)throw new Error("Function is a required argument");t&&(r=r.bind(t));const e=new Grumpy;for(const[t,i]of this)r(i,t,this)&&e.set(t,i);return e}find(r,t){if(void 0===r)throw new Error("Function is a required argument");void 0!==t&&(r=r.bind(t));for(const[t,e]of this)if(r(e,t,this))return e}first(r){if(void 0===r)return this.values().next().value;if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");const t=[r=Math.min(this.size,r)],e=this.values();for(let i=0;i<r;i++)t[i]=e.next().value;return t}firstKey(r){if(void 0===r)return this.keys().next().value;if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");const t=[r=Math.min(this.size,r)],e=this.keys();for(let i=0;i<r;i++)t[i]=e.next().value;return t}flatMap(r,t){const e=this.map(r,t);return(new Grumpy).concat(...e)}keyArray(){return this._keyArray&&this._keyArray.length===this.size||(this._keyArray=[...this.keys()]),this._keyArray}last(r){const t=this.array();if(void 0===r)return t[t.length-1];if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");return t.slice(-r)}lastKey(r){const t=this.keyArray();if(void 0===r)return t[t.length-1];if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");return t.slice(-r)}map(r,t){if(void 0===r)throw new Error("Function is a required argument");t&&(r=r.bind(t));const e=[this.size];let i=0;for(const[t,n]of this)e[i++]=r(n,t,this);return e}mapValues(r,t){if(void 0===r)throw new Error("Function is a required argument");void 0!==t&&(r=r.bind(t));const e=new Grumpy;for(const[t,i]of this)e.set(t,r(i,t,this));return e.array()}random(r){let t=this.array();if(void 0===r)return t[Math.floor(Math.random()*t.length)];if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");if(0===t.length)return[];const e=[r];t=t.slice();for(let i=0;i<r;i++)e[i]=t.splice(Math.floor(Math.random()*t.length),1)[0];return e}randomKey(r){let t=this.keyArray();if(void 0===r)return t[Math.floor(Math.random()*t.length)];if(!Number.isInteger(r)||r<1)throw new RangeError("Count must be an integer greater than 0");if(0===t.length)return[];const e=[r];t=t.slice();for(let i=0;i<r;i++)e[i]=t.splice(Math.floor(Math.random()*t.length),1)[0];return e}reduce(r,t){if(void 0===r)throw new Error("Function is a required argument");let e;if(void 0!==t){e=t;for(const[t,i]of this)e=r(e,i,t,this)}else{let t=!0;for(const[i,n]of this)t?(e=n,t=!1):e=r(e,n,i,this)}return e}set(r,t,e){if(this._array=null,this._keyArray=null,void 0===r)throw new Error("Key is a required argument");if(void 0===t)throw new Error("Value is a required argument");e?(super.set(r,t),setTimeout(()=>{this.delete(r)},e)):super.set(r,t)}shuffle(){const r=[...this.entries()];let t,e,i=r.length;for(;0!==i;)e=Math.floor(Math.random()*i),t=r[i-=1],r[i]=r[e],r[e]=t;this.clear();for(const[t,e]of r)this.set(t,e);return this}sift(r,t){if(void 0===r)throw new Error("Function is a required argument");t&&(r=r.bind(t));const e=this.size;for(const[t,e]of this)r(e,t,this)&&this.delete(t);return e-this.size}some(r,t){if(void 0===r)throw new Error("Function is a required argument");t&&(r=r.bind(t));for(const[t,e]of this)if(r(e,t,this))return!0;return!1}sort(r=((r,t)=>+(r>t)||+(r===t)-1)){const t=[...this.entries()];t.sort((t,e)=>r(t[1],e[1],t[0],e[0])),this.clear();for(const[r,e]of t)this.set(r,e);return this}sorted(r=((r,t)=>+(r>t)||+(r===t)-1)){return new Grumpy([...this.entries()].sort((t,e)=>r(t[1],e[1],t[0],e[0])))}}module.exports=Grumpy;
